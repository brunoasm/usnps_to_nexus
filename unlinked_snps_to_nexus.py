#!/usr/bin/env python2

#Created by Bruno de Medeiros July 2016
#This script takes as input a *.unlinked_snps file generated by pyRAD
#and outputs a nexus file.
#Optionally, it adds populations to species names, if a CSV file
#with columns 'sample' and 'population' are provided
#The goal is to use it as input file to SNAPP

from collections import Counter, defaultdict
from warnings import warn

#function to unpack ambiguity codes
def unpack_IUPAC(char):
    char = char.upper()
    seqdict = {"R":["G","A"],
         "K":["G","T"],
         "S":["G","C"],
         "Y":["T","C"],
         "W":["T","A"],
         "M":["C","A"],
         "A":["A"],
         "T":["T"],
         "G":["G"],
         "C":["C"],
         "N":["?"],
         "-":["?"]}
    return set(seqdict[char])



#function to recode alignment column
#assuming N is missing data and any character not ATCG is heterozygous
#gaps will be transformed to missing data too
def recode_to_snapp(column):
    column_translated = [unpack_IUPAC(c) for c in column]
    all_nucs = set()
    for c in column_translated:
        all_nucs.update(c)
    all_nucs.difference_update('?')
    if len(all_nucs) > 2:
        warn('Alignment column with >2 alleles removed')
        return None
    if len(all_nucs) < 2:
        warn('Monomorphic alignment column removed')
        return None

    column = [''.join(sorted(c)) for c in column_translated]
    states = set(column)
    all_string = str()
    for c in column:
        if len(c) == 1 and c in 'ATCG':
            all_string += 2 * c
        if len(c) == 2:
            all_string += c

    #create a translation dict from ATCG to 0-2
    counts = Counter(all_string)
    nuc_counts = Counter({i:j for i,j in counts.iteritems() if i in 'ATCG'}).most_common()
    most_common = nuc_counts[0][0]
    translation = {most_common:0,'?':'?'}
    least_common = nuc_counts[1][0]
    translation.update({least_common:2})

    states.difference_update(translation.keys())
    try:
        translation.update({list(states)[0]:1}) #at this point, the only element left in the states set is the heterozygous state, if any
    except IndexError:
        pass

    translated = [translation[i] for i in column]
    return translated

if __name__ == "__main__":
    import argparse, pandas, os
    from Bio import AlignIO
    from Bio.Nexus.Nexus import Nexus


    parser = argparse.ArgumentParser()
    parser.add_argument('input', help = 'path to input file,*.unlinked_snps generated by pyRAD')
    parser.add_argument('-p','--pop-file', help = "path to file with population information. It must be in csv format and contain a column named 'sample' and another named 'population'")
    parser.add_argument('-i','--ipyrad', help = "use this flag to use an ipyrad population file, instead of the standard format", action= "store_true")
    parser.add_argument('-f','--filter', help = "use this flag to filter alleles not present in all populations", action= "store_true")
    

    args = parser.parse_args()

    #read input alignment
    alignment = AlignIO.read(open(args.input),'phylip-relaxed')

    #add populations to species names, if file with population provided
    if args.pop_file is not None:
        if args.ipyrad:
            with open(args.pop_file, 'r') as popfile:
                samp2pop = dict()    
                for line in popfile:
                    line = line.split('#')[0]
                    try:
                        sample, pop =  line.split()
                    except:
                        break
                    if not sample or not pop:
                        break
                    else:
                        samp2pop[sample] = pop
            for i in xrange(len(alignment)):
                new_name = alignment[i].name + '_' + samp2pop[alignment[i].name]
                alignment[i].id = new_name
        else:
            pop_table = pandas.read_csv(args.pop_file)
            for i in xrange(len(alignment)):
                new_name = alignment[i].name + '_' + \
                        pop_table.loc[pop_table['sample'] == alignment[i].name,'population'].iloc[0]
                alignment[i].id = new_name
            
    #filter dataset
    if args.filter:
        pops = [alignment[i].id.split('_')[-1] for i in range(len(alignment))]
        #print pops
        while True:
            #print alignment
            for i in range(alignment.get_alignment_length()):
                pop_dict = defaultdict(int)
                for j in range(len(pops)):
                    if alignment[j,i] != '-':
                        pop_dict[pops[j]] += 1
                #print pop_dict
                if set(pops) - set(pop_dict.keys()): #if not all populations present for a locus, drop an restart search
                    alignment = alignment[:,:i] + alignment[:,i+1:]
                    break
            else: #if for loop runs through the end, break while loop
                break
                        
            
            
                
    #recode input to 0-2
    column_list = [recode_to_snapp(alignment[:,i]) for i in xrange(len(alignment[0]))]
    seq_list = [seq for seq in alignment] #transforming to sequence list to enable removing columns from alignment
    for i in xrange(len(seq_list)):
        seq_list[i].seq = ''.join([str(column[i]) for column in column_list if column is not None])
        

    #create a nexus object to hold the data
    align_nexus = Nexus()
    align_nexus.datatype = 'integerdata'
    align_nexus.symbols = '012'
    for seq in seq_list:
        align_nexus.add_sequence(name =seq.id, sequence = seq.seq)

    #write output as nexus
    outpath = os.path.splitext(os.path.basename(args.input))[0] + '.nex'
    align_nexus.write_nexus_data(outpath)
